(define (sdiff s1 s2)
  (let loop ((clean #t) (a (reverse s1)) (b (reverse s2)))
    (if (null? a) b
      (if (null? b) a
        (let ((r (- (car a) (car b))))
          (if (not (and clean (= 0 r))) (cons r (loop #f (cdr a) (cdr b)))
            (loop #t (cdr a) (cdr b))))))))

(define (scomp a b)
    (let ((la (length a)) (lb (length b)))
      (if (> la lb) 1
        (if (< la lb) -1
          (let loop ((a a) (b b))
            (if (and (null? a) (null? b)) 0
              (if (or (null? a) (> (car a) (car b))) 1
                (if (or (null? b) (< (car a) (car b))) -1
                  (loop (cdr a) (cdr b))))))))))

(define (transfer n ls)
  (cons (+ n (if (null? ls) 0 (car ls)))
        (if (null? ls) '() (cdr ls))))

(define (splus s1 s2)
  (denul
    (reverse
      (let plus ((a (reverse s1)) (b (reverse s2)))
	(if (null? a) b
	  (if (null? b) a
	    (let ((r (+ (car a) (car b))))
	      (cons (modulo r 10)
		    (plus (transfer (inexact->exact (floor (/ r 10))) (cdr a))
			  (cdr b))))))))))

(define (smul s1 s2)
  (let loop ((a (reverse s1)) (b (reverse s2)))
    (if (null? b) '()
      (if (null? a) '()
        (if (pair? b) (splus (loop a (car b)) (append (loop a (cdr b)) '(0)))
          (let ((r (* (car a) b)))
            (splus (list r) (append (loop (cdr a) b) '(0)))))))))

(define (sinverse ls) (map - ls))

(define (sminus s1 s2)
  (denul
      (reverse
        (let loop ((a (reverse s1)) (b (reverse s2)))
          (if (null? a) (if (null? b) '(0) (sinverse b))
            (if (null? b) a
              (let ((r (- (car a) (car b))))
                (if (>= r 0) (cons r (loop (cdr a) (cdr b)))
                  (cons (+ 10 r) (loop (cdr a) (transfer 1 (cdr b))))))))))))

(define (denul ls)
    (if (null? ls) ls
      (if (= 0 (car ls)) (denul (cdr ls))
        ls)))

(define (sdiv s1 D)
  (denul
   (let div ((Q 0) (NN '()) (N s1))
     (let ((rem (sminus NN (smul D (list Q)))))
       (if (>= (scomp rem D) 0) (div (+ Q 1) NN N)
	   (if (null? N) (list Q)
	       (cons Q (div 0 (append rem (list (car N)))
			    (cdr N)))))))))

(define (savg s1 s2)
  (sdiv (splus s1 s2) '(2)))

(define (fixed-point init act ok? avg)
  (let loop ((guess init))
    (let ((res (act guess)))
      (if (ok? guess res) res
          (loop (avg guess res))))))

(define (mkmagnitude n)
  (cons 1 (let lp ((x n)) (if (= 0 x) '() (cons 0 (lp (- x 1)))))))

(define (sout ls)
  (if (null? ls) '()
    (append (map (lambda (c) (- (char->integer c) 48)) (string->list (number->string (car ls))))
            (sout (cdr ls)))))

(define (ssqrt s1)
  (let ((n (sout s1)))
    (let ((init (mkmagnitude (floor (/ (length n) 2)))))
      (let ((ans (fixed-point init
                              (lambda (guess)
                                (sdiv n guess))
                              (lambda (x y)
                                (let ((diff (denul (reverse (sdiff x y)))))
                                  (or (null? diff) (equal? '(1) diff))))
                              savg)))
        (let ((res (scomp n (smul ans ans))))
          (if (< res 0) (sminus ans '(1))
            (if (> res 0) (splus ans '(1))
              ans)))))))

(define (go)
  (let rl ((n (read)) (x '()))
    (if (> n 0) (rl (- n 1) (cons (read) x))
;;      (let ((ls (ssqrt (reverse x))))
      (let ((ls '()))
	(sdiv (reverse x) (sout (list (sqrt (string->number (list->string (reverse (map (lambda (x) (integer->char (+ x 48))) x))))))))
	(sdiv rev.x
	      (sqrt
	       (coerce
		(coerce
		 (reverse
		  (map [coerce (+ 48 _) 'char]
		       x))
		 'str)
		'int)))
	[(rev x) sdiv {[x map <[_ + 48 coerce 'char]>]
		       reverse
		       coerce:R!str
		       coerce:R!int
		       sqrt}]
	(display (length ls)) (newline)
	(let pl ((ls ls))
	  (and (not (null? ls))
	       (display (car ls))
	       (newline)
	       (pl (cdr ls))))))))

(go)
